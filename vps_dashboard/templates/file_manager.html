<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ–‡ä»¶ç®¡ç†å™¨</title>
    <style>
        body { font-family: sans-serif; margin: 2em; background-color: #f4f4f4; color: #333; }
        .container { max-width: 900px; margin: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #555; }
        .nav-buttons { margin-bottom: 1em; }
        .nav-buttons button { padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; background-color: #007bff; color: white; margin-right: 10px; }
        .nav-buttons button:hover { background-color: #0056b3; }
        .file-actions { margin-bottom: 1em; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
        .file-actions input[type="text"] { flex-grow: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
        .file-actions button, .file-actions input[type="file"] { padding: 8px 12px; border: none; border-radius: 4px; background-color: #007bff; color: white; cursor: pointer; }
        .file-actions button:hover { background-color: #0056b3; }
        .file-actions input[type="file"] { background-color: #28a745; }
        .file-actions input[type="file"]:hover { background-color: #218838; }

        .batch-actions {
            margin-bottom: 1em;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
            display: none; /* Initially hidden */
        }
        .batch-actions button {
            margin-right: 10px;
        }

        table { width: 100%; border-collapse: collapse; margin-top: 1em; }
        th, td { padding: 8px; border: 1px solid #ddd; text-align: left; }
        th { background-color: #f2f2f2; }
        .file-item-name a { text-decoration: none; color: #007bff; }
        .file-item-name a:hover { text-decoration: underline; }
        .action-buttons button { margin-right: 5px; padding: 6px 10px; border-radius: 4px; border: 1px solid #ccc; background-color: #f0f0f0; cursor: pointer; }
        .action-buttons button:hover { background-color: #e0e0e0; }
        .action-buttons .delete-btn { background-color: #dc3545; color: white; border-color: #dc3545; }
        .action-buttons .delete-btn:hover { background-color: #c82333; }
        .current-path { font-size: 1.2em; margin-bottom: 1em; }

        #task-status-container {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 1em;
            display: none; /* Initially hidden */
        }
        #task-list {
            list-style-type: none;
            padding-left: 0;
            margin: 0;
        }
        .task-item {
            padding: 8px 5px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .task-item:last-child { border-bottom: none; }
        .task-item .status-running { color: #007bff; font-style: italic; }
        .task-item .status-completed { color: #28a745; }
        .task-item .status-failed { color: #dc3545; font-weight: bold; }
        .task-item .remove-task-btn {
            cursor: pointer;
            color: #aaa;
            font-weight: bold;
            padding: 0 5px;
        }

        #bookmarks { margin-bottom: 1em; padding-bottom: 1em; border-bottom: 1px solid #ddd; }
        .bookmark-item { display: inline-block; margin-right: 10px; background: #e0e0e0; padding: 5px 10px; border-radius: 15px; font-size: 0.9em; }
        .bookmark-item a { text-decoration: none; color: #333; }
        .bookmark-item .delete-bookmark { color: #999; cursor: pointer; margin-left: 8px; font-weight: bold; }
        .bookmark-item .delete-bookmark:hover { color: #f00; }

        .pagination {
            margin-top: 1em;
            text-align: center;
        }
        .pagination button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f0f0f0;
            cursor: pointer;
        }
        .pagination button:disabled {
            cursor: not-allowed;
            background-color: #eee;
        }
        .pagination span {
            margin: 0 1em;
        }

        /* æ¨¡æ€æ¡†é€šç”¨æ ·å¼ */
        .modal {
            display: none; /* é»˜è®¤éšè— */
            position: fixed; /* å›ºå®šå®šä½ */
            z-index: 1; /* ä½äºé¡¶éƒ¨ */
            left: 0;
            top: 0;
            width: 100%; /* æ»¡å®½ */
            height: 100%; /* æ»¡é«˜ */
            overflow: auto; /* å¦‚æœå†…å®¹è¿‡å¤šï¼Œå…è®¸æ»šåŠ¨ */
            background-color: rgba(0,0,0,0.4); /* é»‘è‰²åŠé€æ˜èƒŒæ™¯ */
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto; /* è·é¡¶éƒ¨15%ï¼Œæ°´å¹³å±…ä¸­ */
            padding: 20px;
            border: 1px solid #888;
            width: 80%; /* å®½åº¦ */
            max-width: 800px;
            border-radius: 8px;
            position: relative;
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        
        /* ç¼–è¾‘å™¨æ¨¡æ€æ¡†æ ·å¼ */
        #editor-textarea {
            width: 100%;
            height: 400px;
            font-family: monospace;
            font-size: 0.9em;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box; /* åŒ…å«paddingå’Œborderåœ¨å®½åº¦å†… */
            resize: vertical; /* å…è®¸å‚ç›´è°ƒæ•´å¤§å° */
        }
        .editor-buttons {
            margin-top: 1em;
            text-align: right;
        }
        .editor-buttons button {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .editor-buttons .save-btn { background-color: #28a745; color: white; }
        .editor-buttons .cancel-btn { background-color: #6c757d; color: white; }

        /* æƒé™æ¨¡æ€æ¡†æ ·å¼ */
        #permissions-modal-content {
            text-align: left;
        }
        #permissions-modal-content input[type="text"] {
            width: calc(100% - 22px);
            padding: 8px;
            margin-top: 5px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .permission-rwx {
            display: flex;
            justify-content: space-around;
            margin-bottom: 1em;
        }
        .permission-group {
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
        }
        .permission-group label {
            display: block;
        }

        /* å‹ç¼©/è§£å‹æ¨¡æ€æ¡†æ ·å¼ */
        #compress-modal-content, #decompress-modal-content {
            text-align: left;
        }
        #compress-modal-content select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        /* é€šçŸ¥æ ·å¼ */
        #notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1050;
            width: 300px;
        }
        .notification {
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            color: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            opacity: 0.9;
            transition: opacity 0.5s, transform 0.5s;
        }
        .notification.success { background-color: #28a745; }
        .notification.error { background-color: #dc3545; }
        .notification.info { background-color: #17a2b8; }
        .notification.warning { background-color: #ffc107; color: #333; }

    </style>
</head>
<body>
    <div id="notification-container"></div>
    <div class="container">
        <h1>æ–‡ä»¶ç®¡ç†å™¨</h1>
        <p><a href="{{ base_path }}/logout">é€€å‡ºç™»å½•</a></p>
        <div class="nav-buttons">
            <button onclick="location.href='{{ base_path }}/dashboard'">ä»ªè¡¨ç›˜</button>
            <button onclick="location.href='{{ base_path }}/file_manager'">æ–‡ä»¶ç®¡ç†</button>
            <button onclick="location.href='{{ base_path }}/process_manager'">è¿›ç¨‹ç®¡ç†</button>
            <button onclick="location.href='{{ base_path }}/terminal'">Webç»ˆç«¯</button>
            <button onclick="location.href='{{ base_path }}/systemd_manager'">å®šæ—¶ä»»åŠ¡</button>
            <button onclick="location.href='{{ base_path }}/screen_manager'">Screenä¼šè¯</button>
        </div>
        <h3 class="current-path" id="current-path">/</h3>

        <div id="task-status-container">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <h5>åå°ä»»åŠ¡</h5>
                <button onclick="clearCompletedTasks()" style="padding: 2px 8px; font-size: 0.8em;">æ¸…é™¤å·²å®Œæˆ</button>
            </div>
            <ul id="task-list"></ul>
        </div>

        <div id="bookmarks">
            <h4>ä¹¦ç­¾</h4>
            <div id="bookmark-list"></div>
        </div>

        <div class="file-actions">
            <input type="text" id="new-folder-name" placeholder="æ–°æ–‡ä»¶å¤¹åç§°">
            <button onclick="createFolder()">åˆ›å»ºæ–‡ä»¶å¤¹</button>
            <input type="file" id="fileUploadInput">
            <button onclick="uploadFile()">ä¸Šä¼ æ–‡ä»¶</button>
            <button onclick="createNewFile()">æ–°å»ºæ–‡ä»¶</button>
        </div>
        <div class="file-actions" style="margin-top: 10px;">
            <input type="text" id="search-query" placeholder="åœ¨å½“å‰ç›®å½•æœç´¢...">
            <button onclick="searchFiles()">æœç´¢</button>
            <button onclick="fetchFiles(currentPath, 1)">æ¸…é™¤æœç´¢</button>
        </div>

        <div id="batch-actions-container" class="batch-actions">
            <button onclick="batchDelete()">æ‰¹é‡åˆ é™¤</button>
            <button onclick="copySelected()">å¤åˆ¶</button>
            <button onclick="cutSelected()">å‰ªåˆ‡</button>
            <button onclick="paste()" id="paste-button" style="display: none;">ç²˜è´´</button>
        </div>

        <table>
            <thead>
                <tr>
                    <th><input type="checkbox" id="select-all-checkbox"></th>
                    <th>åç§°</th>
                    <th>ç±»å‹</th>
                    <th>å¤§å°</th>
                    <th>æœ€åä¿®æ”¹æ—¶é—´</th>
                    <th>æƒé™</th>
                    <th>æ“ä½œ</th>
                </tr>
            </thead>
            <tbody id="file-list">
                <!-- æ–‡ä»¶åˆ—è¡¨å°†ç”±JavaScriptå¡«å…… -->
            </tbody>
        </table>
        <div class="pagination">
            <button id="prev-page-btn" disabled>ä¸Šä¸€é¡µ</button>
            <span id="page-info"></span>
            <button id="next-page-btn" disabled>ä¸‹ä¸€é¡µ</button>
        </div>
    </div>

    <!-- æ–‡ä»¶ç¼–è¾‘å™¨æ¨¡æ€æ¡† -->
    <div id="file-editor-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeEditorModal()">&times;</span>
            <h2>ç¼–è¾‘æ–‡ä»¶: <span id="editing-file-path"></span></h2>
            <textarea id="editor-textarea"></textarea>
            <div class="editor-buttons">
                <button class="save-btn" onclick="saveFileContent()">ä¿å­˜</button>
                <button class="cancel-btn" onclick="closeEditorModal()">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- æƒé™è®¾ç½®æ¨¡æ€æ¡† -->
    <div id="permissions-modal" class="modal">
        <div class="modal-content" id="permissions-modal-content">
            <span class="close-button" onclick="closePermissionsModal()">&times;</span>
            <h2>è®¾ç½®æƒé™: <span id="permissions-file-path"></span></h2>
            <label for="octal-permission">å…«è¿›åˆ¶æƒé™ (ä¾‹å¦‚: 755):</label>
            <input type="text" id="octal-permission" maxlength="4" pattern="[0-7]{3,4}" title="è¯·è¾“å…¥3æˆ–4ä½å…«è¿›åˆ¶æƒé™ç  (ä¾‹å¦‚ 755)">
            
            <div class="permission-rwx">
                <div class="permission-group">
                    <h4>æ‰€æœ‰è€… (Owner)</h4>
                    <label><input type="checkbox" id="owner-read"> è¯»å– (r)</label>
                    <label><input type="checkbox" id="owner-write"> å†™å…¥ (w)</label>
                    <label><input type="checkbox" id="owner-execute"> æ‰§è¡Œ (x)</label>
                </div>
                <div class="permission-group">
                    <h4>ç»„ (Group)</h4>
                    <label><input type="checkbox" id="group-read"> è¯»å– (r)</label>
                    <label><input type="checkbox" id="group-write"> å†™å…¥ (w)</label>
                    <label><input type="checkbox" id="group-execute"> æ‰§è¡Œ (x)</label>
                </div>
                <div class="permission-group">
                    <h4>å…¶ä»– (Others)</h4>
                    <label><input type="checkbox" id="others-read"> è¯»å– (r)</label>
                    <label><input type="checkbox" id="others-write"> å†™å…¥ (w)</label>
                    <label><input type="checkbox" id="others-execute"> æ‰§è¡Œ (x)</label>
                </div>
            </div>

            <div class="editor-buttons">
                <button class="save-btn" onclick="savePermissions()">ä¿å­˜</button>
                <button class="cancel-btn" onclick="closePermissionsModal()">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- å‹ç¼©æ¨¡æ€æ¡† -->
    <div id="compress-modal" class="modal">
        <div class="modal-content" id="compress-modal-content">
            <span class="close-button" onclick="closeCompressModal()">&times;</span>
            <h2>å‹ç¼©: <span id="compress-file-path"></span></h2>
            <label for="compress-format">é€‰æ‹©å‹ç¼©æ ¼å¼:</label>
            <select id="compress-format">
                <option value="zip">.zip</option>
                <option value="tar.gz">.tar.gz</option>
            </select>
            <div class="editor-buttons">
                <button class="save-btn" onclick="performCompress()">å‹ç¼©</button>
                <button class="cancel-btn" onclick="closeCompressModal()">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- è§£å‹æ¨¡æ€æ¡† -->
    <div id="decompress-modal" class="modal">
        <div class="modal-content" id="decompress-modal-content">
            <span class="close-button" onclick="closeDecompressModal()">&times;</span>
            <h2>è§£å‹: <span id="decompress-file-path"></span></h2>
            <p>æ–‡ä»¶å°†è§£å‹åˆ°å½“å‰ç›®å½•ã€‚</p>
            <div class="editor-buttons">
                <button class="save-btn" onclick="performDecompress()">è§£å‹</button>
                <button class="cancel-btn" onclick="closeDecompressModal()">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <script>
        // --- é€šçŸ¥ç³»ç»Ÿ ---
        let isDismissListenerActive = false;

        function dismissAllNotifications() {
            document.querySelectorAll('.notification').forEach(notification => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => notification.remove(), 500);
            });
            isDismissListenerActive = false; // é‡ç½®ç›‘å¬å™¨çŠ¶æ€
        }

        function showNotification(message, type = 'info') {
            const container = document.getElementById('notification-container');
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            container.appendChild(notification);

            // å¦‚æœè¿˜æ²¡æœ‰è®¾ç½®â€œäº¤äº’åæ¶ˆå¤±â€çš„ç›‘å¬å™¨ï¼Œåˆ™è®¾ç½®ä¸€ä¸ª
            if (!isDismissListenerActive) {
                isDismissListenerActive = true;
                const dismissHandler = () => {
                    dismissAllNotifications();
                    document.removeEventListener('mousedown', dismissHandler);
                    document.removeEventListener('keydown', dismissHandler);
                };
                // ç›‘å¬é¼ æ ‡æˆ–é”®ç›˜äº‹ä»¶ï¼Œä¸€æ—¦è§¦å‘å°±ç§»é™¤æ‰€æœ‰é€šçŸ¥
                document.addEventListener('mousedown', dismissHandler);
                document.addEventListener('keydown', dismissHandler);
            }
        }

        const basePath = '{{ base_path }}';
        let currentEditingFilePath = ''; // ç”¨äºä¿å­˜å½“å‰ç¼–è¾‘çš„æ–‡ä»¶è·¯å¾„
        let currentPermissionsPath = ''; // ç”¨äºä¿å­˜å½“å‰è®¾ç½®æƒé™çš„æ–‡ä»¶è·¯å¾„
        let currentCompressPath = ''; // ç”¨äºä¿å­˜å½“å‰å‹ç¼©çš„æ–‡ä»¶/æ–‡ä»¶å¤¹è·¯å¾„
        let currentDecompressPath = ''; // ç”¨äºä¿å­˜å½“å‰è§£å‹çš„æ–‡ä»¶è·¯å¾„
        let currentPage = 1;
        let totalPages = 1;
        let currentPath = '';
        let clipboard = {
            type: null, // 'copy' or 'cut'
            paths: []
        };

        document.addEventListener('DOMContentLoaded', () => {
            fetchFiles('');
            fetchBookmarks();
            fetchTasks(); // é¡µé¢åŠ è½½æ—¶è·å–ä»»åŠ¡åˆ—è¡¨
            document.getElementById('prev-page-btn').addEventListener('click', () => {
                if (currentPage > 1) {
                    fetchFiles(currentPath, currentPage - 1);
                }
            });
            document.getElementById('next-page-btn').addEventListener('click', () => {
                if (currentPage < totalPages) {
                    fetchFiles(currentPath, currentPage + 1);
                }
            });
            document.getElementById('search-query').addEventListener('keyup', (event) => {
                if (event.key === 'Enter') {
                    searchFiles();
                }
            });

            // å…¨é€‰å¤é€‰æ¡†é€»è¾‘
            document.getElementById('select-all-checkbox').addEventListener('change', (event) => {
                document.querySelectorAll('#file-list .file-checkbox').forEach(checkbox => {
                    checkbox.checked = event.target.checked;
                });
                updateBatchActionsVisibility();
            });
        });

        function searchFiles() {
            const query = document.getElementById('search-query').value.trim();
            if (!query) {
                showNotification('è¯·è¾“å…¥æœç´¢å†…å®¹ã€‚', 'warning');
                return;
            }
            fetchFiles(currentPath, 1, true, query);
        }

        async function fetchFiles(path, page = 1, search = false, query = '') {
            currentPath = path;
            currentPage = page;
            try {
                let url = '';
                if (search) {
                    url = `${basePath}/file_manager/files/search?query=${encodeURIComponent(query)}&path=${encodeURIComponent(path)}`;
                } else {
                    url = `${basePath}/file_manager/files?path=${encodeURIComponent(path)}&page=${page}`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                const fileList = document.getElementById('file-list');
                const currentPathEl = document.getElementById('current-path');
                
                currentPathEl.textContent = `å½“å‰è·¯å¾„: ${data.current_full_path}`;
                fileList.innerHTML = ''; // æ¸…ç©ºç°æœ‰åˆ—è¡¨

                if (data.status === 'error') {
                    showNotification('é”™è¯¯: ' + data.message, 'error');
                    return;
                }

                const files = data.items;
                totalPages = data.total_pages;
                currentPage = data.current_page;

                updatePaginationControls(data.is_search_result);

                files.forEach(file => {
                    const row = fileList.insertRow();

                    // Checkbox cell
                    const checkboxCell = row.insertCell();
                    if (file.name !== '..') {
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'file-checkbox';
                        checkbox.dataset.path = file.path;
                        checkbox.addEventListener('change', updateBatchActionsVisibility);
                        checkboxCell.appendChild(checkbox);
                    }
                    
                    const nameCell = row.insertCell();
                    nameCell.className = 'file-item-name';
                    const link = document.createElement('a');
                    link.href = '#';
                    link.textContent = `${file.type === 'directory' ? 'ğŸ“' : 'ğŸ“„'} ${file.name}`;
                    if (file.type === 'directory') {
                        link.onclick = (e) => {
                            e.preventDefault();
                            fetchFiles(file.path, 1); // åˆ‡æ¢ç›®å½•æ—¶å›åˆ°ç¬¬ä¸€é¡µ
                        };
                    }
                    nameCell.appendChild(link);

                    row.insertCell().textContent = file.type === 'directory' ? 'æ–‡ä»¶å¤¹' : 'æ–‡ä»¶';
                    row.insertCell().textContent = file.size !== null ? formatBytes(file.size) : 'N/A';
                    row.insertCell().textContent = file.last_modified ? new Date(file.last_modified).toLocaleString() : 'N/A';
                    row.insertCell().textContent = file.permissions ? file.permissions.slice(-3) : 'N/A'; // æ˜¾ç¤ºåä¸‰ä½å…«è¿›åˆ¶æƒé™

                    const actionsCell = row.insertCell();
                    actionsCell.className = 'action-buttons';

                    if (file.type === 'file') {
                        const downloadButton = document.createElement('button');
                        downloadButton.textContent = 'ä¸‹è½½';
                        downloadButton.onclick = () => {
                            window.location.href = `${basePath}/file_manager/files/download?path=${encodeURIComponent(file.path)}`;
                        };
                        actionsCell.appendChild(downloadButton);

                        // ç®€å•çš„æ–‡æœ¬æ–‡ä»¶åˆ¤æ–­ï¼Œå¯æ ¹æ®å®é™…æ–‡ä»¶ç±»å‹æ‰©å±•
                        if (file.name.match(/\.(txt|log|conf|config|json|py|sh|js|css|html|xml|md)$/i)) {
                            const editButton = document.createElement('button');
                            editButton.textContent = 'ç¼–è¾‘';
                            editButton.onclick = () => openFileInEditor(file.path);
                            actionsCell.appendChild(editButton);
                        }

                        // åˆ¤æ–­æ˜¯å¦æ˜¯å‹ç¼©æ–‡ä»¶
                        if (file.name.match(/\.(zip|tar\.gz)$/i)) {
                            const decompressButton = document.createElement('button');
                            decompressButton.textContent = 'è§£å‹';
                            decompressButton.onclick = () => openDecompressModal(file.path);
                            actionsCell.appendChild(decompressButton);
                        }
                    }

                    if (file.type === 'directory' && file.name !== '..') {
                        const bookmarkButton = document.createElement('button');
                        bookmarkButton.textContent = 'â­';
                        bookmarkButton.title = 'æ·»åŠ ä¹¦ç­¾';
                        bookmarkButton.onclick = () => addBookmark(file.path);
                        actionsCell.appendChild(bookmarkButton);
                    }
                    
                    if (file.name !== '..') { // ä¸å…è®¸é‡å‘½åã€åˆ é™¤ã€è®¾ç½®â€œ..â€çš„æƒé™æˆ–å‹ç¼©
                        const renameButton = document.createElement('button');
                        renameButton.textContent = 'é‡å‘½å';
                        renameButton.onclick = () => renameFile(file.path, file.name);
                        actionsCell.appendChild(renameButton);

                        const deleteButton = document.createElement('button');
                        deleteButton.textContent = 'åˆ é™¤';
                        deleteButton.className = 'delete-btn';
                        deleteButton.onclick = () => deleteFile(file.path);
                        actionsCell.appendChild(deleteButton);

                        const permissionsButton = document.createElement('button');
                        permissionsButton.textContent = 'æƒé™';
                        permissionsButton.onclick = () => openPermissionsModal(file.path);
                        actionsCell.appendChild(permissionsButton);

                        const compressButton = document.createElement('button');
                        compressButton.textContent = 'å‹ç¼©';
                        compressButton.onclick = () => openCompressModal(file.path);
                        actionsCell.appendChild(compressButton);
                    }
                });
            } catch (error) {
                console.error('Error fetching files:', error);
                showNotification('è·å–æ–‡ä»¶åˆ—è¡¨æ—¶å‘ç”Ÿé”™è¯¯ã€‚', 'error');
            }
        }
        
        function updatePaginationControls(is_search = false) {
            const paginationDiv = document.querySelector('.pagination');
            if (is_search) {
                paginationDiv.style.display = 'none';
                return;
            }
            
            paginationDiv.style.display = 'block';
            const pageInfo = document.getElementById('page-info');
            const prevBtn = document.getElementById('prev-page-btn');
            const nextBtn = document.getElementById('next-page-btn');

            pageInfo.textContent = `ç¬¬ ${currentPage} é¡µ / å…± ${totalPages} é¡µ`;
            prevBtn.disabled = currentPage <= 1;
            nextBtn.disabled = currentPage >= totalPages;
        }
        
        async function createFolder() {
            const folderNameInput = document.getElementById('new-folder-name');
            const folderName = folderNameInput.value.trim();
            const path = currentPath ? `${currentPath}/${folderName}` : folderName;

            if (!folderName) {
                showNotification('è¯·è¾“å…¥æ–‡ä»¶å¤¹åç§°ã€‚', 'warning');
                return;
            }

            try {
                const response = await fetch(`${basePath}/file_manager/files/create_folder`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: path })
                });
                const result = await response.json();
                if (result.status === 'success') {
                    showNotification(result.message, 'success');
                    folderNameInput.value = '';
                    fetchFiles(currentPath);
                } else {
                    showNotification('åˆ›å»ºå¤±è´¥: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Error creating folder:', error);
                showNotification('åˆ›å»ºæ–‡ä»¶å¤¹æ—¶å‘ç”Ÿé”™è¯¯ã€‚', 'error');
            }
        }

        async function renameFile(oldPath, oldName) {
            const newName = prompt(`è¾“å…¥æ–°çš„åç§°ï¼ŒåŸåç§°ä¸º "${oldName}":`, oldName);
            if (newName === null || newName.trim() === '' || newName === oldName) {
                return; // ç”¨æˆ·å–æ¶ˆæˆ–æœªåšæ›´æ”¹
            }
            
            const newPath = currentPath ? `${currentPath}/${newName.trim()}` : newName.trim();

            try {
                const response = await fetch(`${basePath}/file_manager/files/rename`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ old_path: oldPath, new_path: newPath })
                });
                const result = await response.json();
                if (result.status === 'success') {
                    showNotification(result.message, 'success');
                    fetchFiles(currentPath);
                } else {
                    showNotification('é‡å‘½åå¤±è´¥: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Error renaming file:', error);
                showNotification('é‡å‘½åæ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯ã€‚', 'error');
            }
        }

        async function deleteFile(path) {
            if (!confirm(`ç¡®å®šè¦åˆ é™¤ ${path} å—ï¼Ÿæ­¤æ“ä½œä¸å¯é€†ï¼`)) {
                return;
            }
            try {
                const response = await fetch(`${basePath}/file_manager/files/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: path })
                });
                const result = await response.json();
                if (result.status === 'success') {
                    showNotification(result.message, 'success');
                    fetchFiles(currentPath);
                } else {
                    showNotification('åˆ é™¤å¤±è´¥: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Error deleting file:', error);
                showNotification('åˆ é™¤æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯ã€‚', 'error');
            }
        }

        async function uploadFile() {
            const fileInput = document.getElementById('fileUploadInput');
            const file = fileInput.files[0];

            if (!file) {
                showNotification('è¯·é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶ã€‚', 'warning');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);
            formData.append('path', currentPath);

            try {
                const response = await fetch(`${basePath}/file_manager/files/upload`, {
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();
                if (result.status === 'success') {
                    showNotification(result.message, 'success');
                    fetchFiles(currentPath);
                } else {
                    showNotification('ä¸Šä¼ å¤±è´¥: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Error uploading file:', error);
                showNotification('ä¸Šä¼ æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯ã€‚', 'error');
            }
        }

        async function createNewFile() {
            const fileName = prompt("è¯·è¾“å…¥æ–°æ–‡ä»¶çš„åç§° (ä¾‹å¦‚: new_file.txt):");
            if (fileName === null || fileName.trim() === '') {
                return;
            }

            const filePath = currentPath ? `${currentPath}/${fileName.trim()}` : fileName.trim();
            
            // å°è¯•åˆ›å»ºä¸€ä¸ªç©ºæ–‡ä»¶
            try {
                const response = await fetch(`${basePath}/file_manager/files/save_content`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: filePath, content: '' }) // åˆ›å»ºä¸€ä¸ªç©ºæ–‡ä»¶
                });
                const result = await response.json();
                if (result.status === 'success') {
                    showNotification(result.message, 'success');
                    fetchFiles(currentPath); // åˆ·æ–°æ–‡ä»¶åˆ—è¡¨
                    // è‡ªåŠ¨æ‰“å¼€æ–°åˆ›å»ºçš„æ–‡ä»¶è¿›è¡Œç¼–è¾‘
                    openFileInEditor(filePath);
                } else {
                    showNotification('åˆ›å»ºæ–°æ–‡ä»¶å¤±è´¥: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Error creating new file:', error);
                showNotification('åˆ›å»ºæ–°æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯ã€‚', 'error');
            }
        }

        async function openFileInEditor(filePath) {
            try {
                const response = await fetch(`${basePath}/file_manager/files/get_content?path=${encodeURIComponent(filePath)}`);
                const data = await response.json();

                if (data.status === 'success') {
                    document.getElementById('editing-file-path').textContent = filePath;
                    document.getElementById('editor-textarea').value = data.content;
                    currentEditingFilePath = filePath; // ä¿å­˜å½“å‰ç¼–è¾‘çš„æ–‡ä»¶è·¯å¾„
                    
                    if (data.truncated) {
                        showNotification("æ–‡ä»¶è¿‡å¤§ï¼Œä»…æ˜¾ç¤ºéƒ¨åˆ†å†…å®¹ä»¥ä¾›é¢„è§ˆã€‚ä¿å­˜æ“ä½œå°†è¦†ç›–æ•´ä¸ªæ–‡ä»¶ã€‚", 'warning');
                    }

                    document.getElementById('file-editor-modal').style.display = 'block'; // æ˜¾ç¤ºæ¨¡æ€æ¡†
                } else {
                    showNotification('è¯»å–æ–‡ä»¶å¤±è´¥: ' + data.message, 'error');
                }
            } catch (error) {
                console.error('Error opening file in editor:', error);
                showNotification('æ‰“å¼€æ–‡ä»¶ç¼–è¾‘å™¨æ—¶å‘ç”Ÿé”™è¯¯ã€‚', 'error');
            }
        }

        async function saveFileContent() {
            const content = document.getElementById('editor-textarea').value;
            if (!currentEditingFilePath) {
                showNotification('æ²¡æœ‰è¦ä¿å­˜çš„æ–‡ä»¶è·¯å¾„ã€‚', 'error');
                return;
            }

            try {
                const response = await fetch(`${basePath}/file_manager/files/save_content`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: currentEditingFilePath, content: content })
                });
                const result = await response.json();
                if (result.status === 'success') {
                    showNotification(result.message, 'success');
                    closeEditorModal(); // ä¿å­˜æˆåŠŸåå…³é—­ç¼–è¾‘å™¨
                    fetchFiles(currentPath); // åˆ·æ–°æ–‡ä»¶åˆ—è¡¨ä»¥æ›´æ–°æ–‡ä»¶å¤§å°/ä¿®æ”¹æ—¶é—´
                } else {
                    showNotification('ä¿å­˜æ–‡ä»¶å¤±è´¥: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Error saving file content:', error);
                showNotification('ä¿å­˜æ–‡ä»¶å†…å®¹æ—¶å‘ç”Ÿé”™è¯¯ã€‚', 'error');
            }
        }

        function closeEditorModal() {
            document.getElementById('file-editor-modal').style.display = 'none';
            document.getElementById('editor-textarea').value = ''; // æ¸…ç©ºå†…å®¹
            currentEditingFilePath = ''; // æ¸…ç©ºå½“å‰ç¼–è¾‘æ–‡ä»¶è·¯å¾„
        }

        // --- æƒé™ç®¡ç†åŠŸèƒ½ ---
        async function openPermissionsModal(filePath) {
            currentPermissionsPath = filePath;
            document.getElementById('permissions-file-path').textContent = filePath;
            document.getElementById('octal-permission').value = ''; // æ¸…ç©ºå…«è¿›åˆ¶è¾“å…¥æ¡†
            resetPermissionCheckboxes(); // æ¸…ç©ºå¤é€‰æ¡†

            try {
                const response = await fetch(`${basePath}/file_manager/files/permissions?path=${encodeURIComponent(filePath)}`);
                const data = await response.json();
                if (data.status === 'success') {
                    const octal = data.permissions.slice(-3); // è·å–åä¸‰ä½å…«è¿›åˆ¶æƒé™
                    document.getElementById('octal-permission').value = octal;
                    updateCheckboxesFromOctal(octal);
                } else {
                    showNotification('è·å–æƒé™å¤±è´¥: ' + data.message, 'error');
                }
            } catch (error) {
                console.error('Error fetching permissions:', error);
                showNotification('è·å–æƒé™æ—¶å‘ç”Ÿé”™è¯¯ã€‚', 'error');
            }
            document.getElementById('permissions-modal').style.display = 'block';
        }

        function closePermissionsModal() {
            document.getElementById('permissions-modal').style.display = 'none';
            currentPermissionsPath = '';
        }

        async function savePermissions() {
            const octalInput = document.getElementById('octal-permission').value.trim();
            if (!octalInput.match(/^[0-7]{3,4}$/)) {
                showNotification('è¯·è¾“å…¥æœ‰æ•ˆçš„3æˆ–4ä½å…«è¿›åˆ¶æƒé™ç  (ä¾‹å¦‚ 755)ã€‚', 'warning');
                return;
            }

            try {
                const response = await fetch(`${basePath}/file_manager/files/permissions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: currentPermissionsPath, permissions: octalInput })
                });
                const result = await response.json();
                if (result.status === 'success') {
                    showNotification(result.message, 'success');
                    closePermissionsModal();
                    fetchFiles(currentPath); // åˆ·æ–°æ–‡ä»¶åˆ—è¡¨ä»¥æ›´æ–°æƒé™æ˜¾ç¤º
                } else {
                    showNotification('ä¿å­˜æƒé™å¤±è´¥: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Error saving permissions:', error);
                showNotification('ä¿å­˜æƒé™æ—¶å‘ç”Ÿé”™è¯¯ã€‚', 'error');
            }
        }

        function octalToBinary(octal) {
            // å°†å…«è¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢ä¸º9ä½äºŒè¿›åˆ¶å­—ç¬¦ä¸²
            return parseInt(octal, 8).toString(2).padStart(9, '0');
        }

        function binaryToOctal(binary) {
            // å°†9ä½äºŒè¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢ä¸ºå…«è¿›åˆ¶
            return parseInt(binary, 2).toString(8).padStart(3, '0');
        }

        function updateCheckboxesFromOctal(octal) {
            resetPermissionCheckboxes();
            if (!octal || octal.length < 3) return;
            const binary = octalToBinary(octal.slice(-3)); // åªå–åä¸‰ä½

            const checkboxes = [
                document.getElementById('owner-read'), document.getElementById('owner-write'), document.getElementById('owner-execute'),
                document.getElementById('group-read'), document.getElementById('group-write'), document.getElementById('group-execute'),
                document.getElementById('others-read'), document.getElementById('others-write'), document.getElementById('others-execute')
            ];

            for (let i = 0; i < 9; i++) {
                checkboxes[i].checked = binary[i] === '1';
            }
        }

        function updateOctalFromCheckboxes() {
            const checkboxes = [
                document.getElementById('owner-read'), document.getElementById('owner-write'), document.getElementById('owner-execute'),
                document.getElementById('group-read'), document.getElementById('group-write'), document.getElementById('group-execute'),
                document.getElementById('others-read'), document.getElementById('others-write'), document.getElementById('others-execute')
            ];
            let binary = '';
            checkboxes.forEach(cb => {
                binary += cb.checked ? '1' : '0';
            });
            document.getElementById('octal-permission').value = binaryToOctal(binary);
        }

        function resetPermissionCheckboxes() {
            const checkboxes = [
                document.getElementById('owner-read'), document.getElementById('owner-write'), document.getElementById('owner-execute'),
                document.getElementById('group-read'), document.getElementById('group-write'), document.getElementById('group-execute'),
                document.getElementById('others-read'), document.getElementById('others-write'), document.getElementById('others-execute')
            ];
            checkboxes.forEach(cb => cb.checked = false);
        }

        // ç›‘å¬å…«è¿›åˆ¶è¾“å…¥æ¡†çš„å˜åŒ–
        document.getElementById('octal-permission').addEventListener('input', (event) => {
            const octal = event.target.value.trim();
            if (octal.match(/^[0-7]{3,4}$/)) {
                updateCheckboxesFromOctal(octal.slice(-3));
            } else {
                resetPermissionCheckboxes();
            }
        });

        // ç›‘å¬å¤é€‰æ¡†çš„å˜åŒ–
        document.querySelectorAll('.permission-group input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', updateOctalFromCheckboxes);
        });

        // --- å‹ç¼©/è§£å‹åŠŸèƒ½ ---
        async function openCompressModal(filePath) {
            currentCompressPath = filePath;
            document.getElementById('compress-file-path').textContent = filePath;
            document.getElementById('compress-modal').style.display = 'block';
        }

        function closeCompressModal() {
            document.getElementById('compress-modal').style.display = 'none';
            currentCompressPath = '';
        }

        async function performCompress() {
            const format = document.getElementById('compress-format').value;
            if (!currentCompressPath) {
                showNotification('æ²¡æœ‰è¦å‹ç¼©çš„æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹è·¯å¾„ã€‚', 'error');
                return;
            }

            try {
                const response = await fetch(`${basePath}/file_manager/files/compress`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: currentCompressPath, format: format })
                });

                if (response.status === 202) { // 202 Accepted
                    const result = await response.json();
                    closeCompressModal();
                    const taskDescription = `å‹ç¼© '${currentCompressPath}'`;
                    addTaskToList(result.task_id, taskDescription);
                    pollTaskStatus(result.task_id, taskDescription);
                } else {
                    const result = await response.json();
                    showNotification('æäº¤å‹ç¼©ä»»åŠ¡å¤±è´¥: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Error starting compression task:', error);
                showNotification('å¼€å§‹å‹ç¼©ä»»åŠ¡æ—¶å‘ç”Ÿç½‘ç»œé”™è¯¯ã€‚', 'error');
            }
        }

        function addTaskToList(taskId, description) {
            const taskList = document.getElementById('task-list');
            const container = document.getElementById('task-status-container');
            container.style.display = 'block';

            const li = document.createElement('li');
            li.id = `task-${taskId}`;
            li.className = 'task-item';
            li.innerHTML = `
                <span>${description}</span>
                <span class="status-running">è¿›è¡Œä¸­...</span>
            `;
            taskList.appendChild(li);
        }

        function updateTaskInList(taskId, message, statusClass, description) {
            const taskItem = document.getElementById(`task-${taskId}`);
            if (taskItem) {
                taskItem.innerHTML = `
                    <span>${description}</span>
                    <span class="${statusClass}">${message}</span>
                    <span class="remove-task-btn" onclick="removeTaskFromList('${taskId}')">Ã—</span>
                `;
            }
        }

        function removeTaskFromList(taskId) {
            const taskItem = document.getElementById(`task-${taskId}`);
            if (taskItem) {
                taskItem.remove();
            }
            // å¦‚æœåˆ—è¡¨ä¸ºç©ºï¼Œåˆ™éšè—å®¹å™¨
            const taskList = document.getElementById('task-list');
            if (taskList.children.length === 0) {
                document.getElementById('task-status-container').style.display = 'none';
            }
        }

        async function pollTaskStatus(taskId, description) {
            const intervalId = setInterval(async () => {
                try {
                    const response = await fetch(`${basePath}/file_manager/task/${taskId}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const task = await response.json();

                    if (task.status === 'completed') {
                        clearInterval(intervalId);
                        updateTaskInList(taskId, `å®Œæˆ: ${task.result}`, 'status-completed', description);
                        fetchFiles(currentPath);
                    } else if (task.status === 'failed') {
                        clearInterval(intervalId);
                        updateTaskInList(taskId, `å¤±è´¥: ${task.error}`, 'status-failed', description);
                    }
                    // å¦‚æœä»»åŠ¡ä»åœ¨ 'pending' æˆ– 'running'ï¼Œåˆ™ç»§ç»­è½®è¯¢
                } catch (error) {
                    clearInterval(intervalId);
                    console.error('Error polling task status:', error);
                    updateTaskInList(taskId, 'è½®è¯¢å‡ºé”™', 'status-failed', description);
                }
            }, 3000); // æ¯3ç§’è½®è¯¢ä¸€æ¬¡
        }

        async function fetchTasks() {
            try {
                const response = await fetch(`${basePath}/file_manager/tasks`);
                const tasks = await response.json();
                for (const taskId in tasks) {
                    const task = tasks[taskId];
                    const description = task.description || `ä»»åŠ¡ ${taskId.substring(0, 8)}`;
                    addTaskToList(taskId, description);

                    if (task.status === 'completed') {
                        updateTaskInList(taskId, `å®Œæˆ: ${task.result}`, 'status-completed', description);
                    } else if (task.status === 'failed') {
                        updateTaskInList(taskId, `å¤±è´¥: ${task.error}`, 'status-failed', description);
                    } else { // pending or running
                        pollTaskStatus(taskId, description);
                    }
                }
            } catch (error) {
                console.error('Error fetching tasks:', error);
            }
        }

        async function clearCompletedTasks() {
            try {
                const response = await fetch(`${basePath}/file_manager/tasks/clear`, { method: 'POST' });
                const result = await response.json();
                showNotification(result.message, 'success');
                // ä»UIä¸Šç§»é™¤æ‰€æœ‰å·²å®Œæˆ/å¤±è´¥çš„ä»»åŠ¡
                document.querySelectorAll('.status-completed, .status-failed').forEach(el => {
                    const taskItem = el.closest('.task-item');
                    if (taskItem) {
                        taskItem.remove();
                    }
                });
                if (document.getElementById('task-list').children.length === 0) {
                    document.getElementById('task-status-container').style.display = 'none';
                }
            } catch (error) {
                console.error('Error clearing tasks:', error);
                showNotification('æ¸…ç†ä»»åŠ¡æ—¶å‡ºé”™ã€‚', 'error');
            }
        }

        async function openDecompressModal(filePath) {
            currentDecompressPath = filePath;
            document.getElementById('decompress-file-path').textContent = filePath;
            document.getElementById('decompress-modal').style.display = 'block';
        }

        function closeDecompressModal() {
            document.getElementById('decompress-modal').style.display = 'none';
            currentDecompressPath = '';
        }

        async function performDecompress() {
            if (!currentDecompressPath) {
                showNotification('æ²¡æœ‰è¦è§£å‹çš„æ–‡ä»¶è·¯å¾„ã€‚', 'error');
                return;
            }

            try {
                const response = await fetch(`${basePath}/file_manager/files/decompress`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: currentDecompressPath }) // é»˜è®¤è§£å‹åˆ°å½“å‰ç›®å½•
                });
                const result = await response.json();
                if (result.status === 'success') {
                    showNotification(result.message, 'success');
                    closeDecompressModal();
                    fetchFiles(currentPath); // åˆ·æ–°æ–‡ä»¶åˆ—è¡¨
                } else {
                    showNotification('è§£å‹å¤±è´¥: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Error decompressing file:', error);
                showNotification('è§£å‹æ—¶å‘ç”Ÿé”™è¯¯ã€‚', 'error');
            }
        }

        // è¾…åŠ©å‡½æ•°ï¼šæ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        // --- ä¹¦ç­¾åŠŸèƒ½ ---
        async function fetchBookmarks() {
            try {
                const response = await fetch(`${basePath}/file_manager/bookmarks`);
                const bookmarks = await response.json();
                const bookmarkListDiv = document.getElementById('bookmark-list');
                bookmarkListDiv.innerHTML = '';
                bookmarks.forEach(path => {
                    const bookmarkSpan = document.createElement('span');
                    bookmarkSpan.className = 'bookmark-item';
                    
                    const link = document.createElement('a');
                    link.href = '#';
                    link.textContent = path.split('/').pop() || path; // æ˜¾ç¤ºæœ€åä¸€éƒ¨åˆ†ä½œä¸ºåç§°
                    link.onclick = (e) => {
                        e.preventDefault();
                        fetchFiles(path, 1);
                    };

                    const deleteBtn = document.createElement('span');
                    deleteBtn.className = 'delete-bookmark';
                    deleteBtn.textContent = 'x';
                    deleteBtn.title = 'åˆ é™¤ä¹¦ç­¾';
                    deleteBtn.onclick = () => deleteBookmark(path);

                    bookmarkSpan.appendChild(link);
                    bookmarkSpan.appendChild(deleteBtn);
                    bookmarkListDiv.appendChild(bookmarkSpan);
                });
            } catch (error) {
                console.error('Error fetching bookmarks:', error);
            }
        }

        async function addBookmark(path) {
            try {
                const response = await fetch(`${basePath}/file_manager/bookmarks/add`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path })
                });
                const result = await response.json();
                if (result.status === 'success') {
                    fetchBookmarks(); // é‡æ–°åŠ è½½ä¹¦ç­¾
                } else {
                    showNotification('æ·»åŠ ä¹¦ç­¾å¤±è´¥: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Error adding bookmark:', error);
                showNotification('æ·»åŠ ä¹¦ç­¾æ—¶å‡ºé”™ã€‚', 'error');
            }
        }

        async function deleteBookmark(path) {
            if (!confirm(`ç¡®å®šè¦åˆ é™¤ä¹¦ç­¾ "${path}" å—ï¼Ÿ`)) {
                return;
            }
            try {
                const response = await fetch(`${basePath}/file_manager/bookmarks/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path })
                });
                const result = await response.json();
                if (result.status === 'success') {
                    fetchBookmarks(); // é‡æ–°åŠ è½½ä¹¦ç­¾
                } else {
                    showNotification('åˆ é™¤ä¹¦ç­¾å¤±è´¥: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Error deleting bookmark:', error);
                showNotification('åˆ é™¤ä¹¦ç­¾æ—¶å‡ºé”™ã€‚', 'error');
            }
        }
    </script>

    <script>
        // --- æ‰¹é‡æ“ä½œç›¸å…³å‡½æ•° ---

        function updateBatchActionsVisibility() {
            const selectedFiles = getSelectedFiles();
            const container = document.getElementById('batch-actions-container');
            const pasteButton = document.getElementById('paste-button');

            if (selectedFiles.length > 0) {
                container.style.display = 'block';
            } else {
                container.style.display = 'none';
            }

            // æ›´æ–°å…¨é€‰æ¡†çš„çŠ¶æ€
            const allCheckboxes = document.querySelectorAll('#file-list .file-checkbox');
            const selectAllCheckbox = document.getElementById('select-all-checkbox');
            if (allCheckboxes.length > 0 && selectedFiles.length === allCheckboxes.length) {
                selectAllCheckbox.checked = true;
                selectAllCheckbox.indeterminate = false;
            } else if (selectedFiles.length > 0) {
                selectAllCheckbox.indeterminate = true;
            } else {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            }

            // æ§åˆ¶ç²˜è´´æŒ‰é’®çš„æ˜¾ç¤º
            pasteButton.style.display = clipboard.paths.length > 0 ? 'inline-block' : 'none';
        }

        function getSelectedFiles() {
            const selectedFiles = [];
            document.querySelectorAll('#file-list .file-checkbox:checked').forEach(checkbox => {
                selectedFiles.push(checkbox.dataset.path);
            });
            return selectedFiles;
        }

        async function batchDelete() {
            const paths = getSelectedFiles();
            if (paths.length === 0) {
                showNotification('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶æˆ–æ–‡ä»¶å¤¹ã€‚', 'warning');
                return;
            }

            if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${paths.length} ä¸ªé¡¹ç›®å—ï¼Ÿæ­¤æ“ä½œä¸å¯é€†ï¼`)) {
                return;
            }

            try {
                const response = await fetch(`${basePath}/file_manager/files/batch-delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ paths: paths })
                });
                
                if (response.status === 202) {
                    const result = await response.json();
                    const taskDescription = `æ‰¹é‡åˆ é™¤ ${paths.length} ä¸ªé¡¹ç›®`;
                    addTaskToList(result.task_id, taskDescription);
                    pollTaskStatus(result.task_id, taskDescription);
                } else {
                    const result = await response.json();
                    showNotification('æäº¤åˆ é™¤ä»»åŠ¡å¤±è´¥: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Error during batch delete:', error);
                showNotification('æ‰¹é‡åˆ é™¤æ—¶å‘ç”Ÿç½‘ç»œé”™è¯¯ã€‚', 'error');
            }
            // æ¸…ç†UI
            document.querySelectorAll('#file-list .file-checkbox:checked').forEach(c => c.checked = false);
            document.getElementById('select-all-checkbox').checked = false;
            updateBatchActionsVisibility();
            // æ¸…ç©ºå‰ªè´´æ¿ä»¥é¿å…è¯¯æ“ä½œ
            clipboard.type = null;
            clipboard.paths = [];
        }

        function copySelected() {
            const paths = getSelectedFiles();
            if (paths.length === 0) {
                showNotification('è¯·é€‰æ‹©è¦å¤åˆ¶çš„é¡¹ç›®ã€‚', 'warning');
                return;
            }
            clipboard.type = 'copy';
            clipboard.paths = paths;
            showNotification(`å·²å¤åˆ¶ ${paths.length} ä¸ªé¡¹ç›®ã€‚`, 'info');
            updateBatchActionsVisibility(); // æ˜¾ç¤ºç²˜è´´æŒ‰é’®
        }

        function cutSelected() {
            const paths = getSelectedFiles();
            if (paths.length === 0) {
                showNotification('è¯·é€‰æ‹©è¦å‰ªåˆ‡çš„é¡¹ç›®ã€‚', 'warning');
                return;
            }
            clipboard.type = 'move';
            clipboard.paths = paths;
            showNotification(`å·²å‰ªåˆ‡ ${paths.length} ä¸ªé¡¹ç›®ã€‚`, 'info');
            updateBatchActionsVisibility(); // æ˜¾ç¤ºç²˜è´´æŒ‰é’®
        }

        async function paste() {
            if (clipboard.paths.length === 0) {
                showNotification('å‰ªè´´æ¿ä¸ºç©ºã€‚', 'warning');
                return;
            }
            
            const destination = currentPath;
            const operation = clipboard.type;
            const paths = clipboard.paths;

            try {
                const response = await fetch(`${basePath}/file_manager/files/${operation}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sources: paths, destination: destination })
                });

                if (response.status === 202) {
                    const result = await response.json();
                    const op_text = operation === 'copy' ? 'å¤åˆ¶' : 'ç§»åŠ¨';
                    const taskDescription = `${op_text} ${paths.length} ä¸ªé¡¹ç›®åˆ° ${destination || 'å½“å‰ç›®å½•'}`;
                    addTaskToList(result.task_id, taskDescription);
                    pollTaskStatus(result.task_id, taskDescription);
                } else {
                    const result = await response.json();
                    showNotification(`æäº¤ ${operation} ä»»åŠ¡å¤±è´¥: ` + result.message, 'error');
                }
            } catch (error) {
                console.error(`Error during ${operation}:`, error);
                showNotification(`${operation} æ“ä½œæœŸé—´å‘ç”Ÿç½‘ç»œé”™è¯¯ã€‚`, 'error');
            }

            // æ“ä½œåæ¸…ç©ºå‰ªè´´æ¿
            clipboard.type = null;
            clipboard.paths = [];
            updateBatchActionsVisibility();
        }

    </script>
</body>
</html>
